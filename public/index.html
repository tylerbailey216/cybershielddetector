<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phishing &amp; Impersonation Guard</title>
    <link rel="stylesheet" href="/styles.css?v=tsb31">
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        .photo-mode-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0 2px;
            color: #f5f7fa;
            font-size: 14px;
            line-height: 1.4;
            overflow: visible;
            flex-wrap: wrap;
            width: 100%;
        }
        .photo-mode-row span {
            color: inherit;
            flex: 1 1 auto;
            min-width: 0;
            white-space: normal;
        }
        .photo-mode-note {
            color: #d8f5ff;
            font-size: 13px;
            margin: 0 0 8px 0;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <main class="layout">
        <section class="hero hero-shell">
            <div class="hero-content">
                <p class="node-summary">Drop a link, message, or screenshot. We tell you if it looks risky - no clicks needed.</p>
                <ul class="hero-highlights">
                    <li>OCR screenshot scan (links stay non-clickable)</li>
                    <li>OSINT feeds: phish.sinking.yachts, URLHaus</li>
                    <li>Brand impersonation + obfuscated path detection</li>
                </ul>
            </div>
            <div class="hero-visual">
                <div class="grid-lines"></div>
                <div class="hero-logo-wrap">
                    <img src="./cybershieldlogo.png" alt="Cyber Shield" class="hero-logo-large">
                </div>
                <div class="floating-badges">
                    <div class="floating-badge">Never click to check</div>
                    <div class="floating-badge">Checks public threat lists</div>
                    <div class="floating-badge">Screenshot scan (non-clickable links)</div>
                </div>
            </div>
        </section>

        <section class="tree-card" id="guard">
            <div class="tree-header">
                <div>
                    <p class="node-path">Safety guard</p>
                    <h2>Phishing &amp; Impersonation Guard</h2>
                    <p class="node-summary">Paste text or drop a screenshot. We extract links, run heuristics + OSINT, and give a clear verdict.</p>
                </div>
            </div>
            <div class="node-body">
                <div class="addon-grid">
                    <div class="addon-card">
                        <h3>Text / Link check</h3>
                        <p class="node-summary">Paste a DM, comment, or email text. Links stay non-clickable.</p>
                        <textarea id="textInput" rows="6" placeholder="Paste the message or link..."></textarea>
                        <label class="node-summary" style="display:flex;align-items:center;gap:8px;margin:6px 0 2px;">
                            <input type="checkbox" id="osintToggle" checked> <span>Run OSINT (slower)</span>
                        </label>
                        <button class="ghost" type="button" id="scanText">Scan text</button>
                        <div id="textStatus" class="node-summary">Idle</div>
                    </div>
                    <div class="addon-card">
                        <h3>Screenshot scan</h3>
                        <p class="node-summary">Upload PNG/JPG. OCR runs locally; extracted links are shown as text.</p>
                        <input type="file" id="shotInput" accept="image/png,image/jpeg">
                        <label class="node-summary" style="display:flex;align-items:center;gap:8px;margin:6px 0 2px;">
                            <input type="checkbox" id="osintToggleShot" checked> <span>Run OSINT (slower)</span>
                        </label>
                        <label class="photo-mode-row">
                            <input type="checkbox" id="shotPhotoMode" style="flex:0 0 auto;">
                            <span>Photo mode (better for camera pictures of a screen)</span>
                        </label>
                        <div class="photo-mode-note">Photo mode boosts OCR for phone photos of screens.</div>
                        <p class="node-summary" style="margin:2px 0 10px;">Tip: hold steady, avoid glare, fill the frame; screenshots are still most accurate.</p>
                        <button class="ghost" type="button" id="scanShot">Scan screenshot</button>
                        <div id="shotStatus" class="node-summary">Idle</div>
                    </div>
                    <div class="addon-card">
                        <h3>Verdict</h3>
                        <div id="verdictPill" class="risk-pill" style="background:#f5c86220;border:1px solid #f5c86255;color:#f5c862;">Pending</div>
                        <div id="reasonList" class="node-summary" style="margin-top:10px;">No scan yet.</div>
                    </div>
                    <div class="addon-card">
                        <h3>Extracted links</h3>
                        <div id="linksBlock" class="node-summary">None yet.</div>
                    </div>
                    <div class="addon-card">
                        <h3>OSINT checks</h3>
                        <div id="osintBlock" class="node-summary">None yet.</div>
                        <div id="osintProgress" class="osint-progress" style="display:none;">
                            <div id="osintProgressBar" class="osint-progress-bar"></div>
                            <div id="osintProgressText" class="osint-progress-text">Running OSINT...</div>
                        </div>
                    </div>
                    <div class="addon-card">
                        <h3>OCR text (preview)</h3>
                        <div id="ocrPreview" class="node-summary">No OCR text yet.</div>
                        <p class="node-summary" style="margin-top:8px;">OCR = Optical Character Recognition. It reads text inside your screenshot so you can see links and flags without ever clicking them.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="privacy-note">
            Privacy: OCR and heuristics run in your browser. Link intel hits public feeds (phish.sinking.yachts, URLHaus) only when online with the local server.
        </section>

        <section class="tree-card">
            <div class="tree-header">
                <div>
                    <p class="node-path">Support</p>
                    <h2>If this helped you</h2>
                    <p class="node-summary">Donations are always welcome and much appreciated but never required. Thank you for your support!</p>
                </div>
            </div>
            <div class="node-body" style="display:flex; flex-direction:column; gap:14px; align-items:center;">
                <div class="support-actions">
                    <a class="pill-link" href="https://www.paypal.me/garinbailey1" target="_blank" rel="noopener">
                        <img src="./support-paypal.svg" alt="PayPal">
                        <span>@garinbailey1</span>
                    </a>
                    <a class="pill-link" href="https://cash.app/$gbailey216" target="_blank" rel="noopener">
                        <img src="./Square_Cash_app_logo.svg" alt="Cash App">
                        <span>$gbailey216</span>
                    </a>
                </div>
            </div>
        </section>

        <section class="tree-card">
            <div class="tree-header">
                <div>
                    <p class="node-path">About</p>
                    <h2>Who is Do More With Less?</h2>
                    <p class="node-summary">Built by Garin Bailey, Senior IT Specialist (field-tested support, no data collection).</p>
                </div>
            </div>
            <div class="node-body" style="display:flex; flex-direction:column; gap:12px; align-items:center;">
                <p class="support-copy">I help people solve everyday tech problems without collecting their data. This tool runs in your browser only and is not a replacement for your company IT policies.</p>
                <div class="support-actions" style="flex-direction:row; align-items:center; justify-content:center; gap:10px;">
                    <span class="node-summary">Connect:</span>
                    <a class="pill-link" href="https://www.linkedin.com/in/gbailey216/" target="_blank" rel="noopener">
                        <img src="./LinkedIn_icon.svg" alt="LinkedIn">
                        <span>LinkedIn</span>
                    </a>
                </div>
            </div>
        </section>
    </main>

    <script>
    (() => {
        const verdictPill = document.getElementById('verdictPill');
        const reasonList = document.getElementById('reasonList');
        const linksBlock = document.getElementById('linksBlock');
        const osintBlock = document.getElementById('osintBlock');
        const osintProgress = document.getElementById('osintProgress');
        const osintProgressBar = document.getElementById('osintProgressBar');
        const osintProgressText = document.getElementById('osintProgressText');
        const ocrPreview = document.getElementById('ocrPreview');
        const textInput = document.getElementById('textInput');
        const scanText = document.getElementById('scanText');
        const textStatus = document.getElementById('textStatus');
        const shotInput = document.getElementById('shotInput');
        const scanShot = document.getElementById('scanShot');
        const shotStatus = document.getElementById('shotStatus');

        const suspiciousTlds = new Set(['zip','ru','cn','tk','ml','gq','ga','cf','work','top','quest','click','country','rest','cam']);
        const shortenerSet = new Set(['bit.ly','tinyurl.com','t.co','goo.gl','ow.ly','buff.ly','is.gd','rebrand.ly','cutt.ly','shorte.st','lnkd.in','bl.ink']);
        const riskyPathWords = ['login','signin','verify','account','secure','update','billing','invoice','prize','gift','bonus','free','btc','crypto','usdt','wallet','token','auth','reset','payment','appleid','icloud','account-lock','lock-account','reactivate','suspend'];
        const brandWords = ['apple','appleid','icloud','appstore','itunes','meta','facebook','instagram','whatsapp','paypal','bank','usps','ups'];
        const trustedAppleDomains = ['apple.com','icloud.com','appleid.apple.com'];
        const suspiciousDomains = new Set(['brainstormlabserver.com','acftop.com','muet.brainstormlabserver.com']);

        const riskLabel = (score) => score >= 4 ? 'Dangerous' : score >= 2 ? 'Caution' : 'Safe';
        const looksLikeIp = (host) => /^(\d{1,3}\.){3}\d{1,3}$/.test(host);
        const hasPunycode = (host) => host.includes('xn--') || /[^\x00-\x7F]/.test(host);
        const countDots = (host) => (host.match(/\./g) || []).length;
        const isObfuscatedPath = (path) => {
            const trimmed = (path || '/').replace(/^\/+/, '');
            if (!trimmed) return false;
            if (trimmed.length >= 20 && /^[A-Za-z0-9/+_.-]+$/.test(trimmed)) {
                const hasLetters = /[A-Za-z]/.test(trimmed);
                const hasDigits = /\d/.test(trimmed);
                const hasSeparators = /[-_/?.=&]/.test(trimmed);
                if (hasLetters && hasDigits && !hasSeparators) return true;
            }
            return false;
        };

        const extractUrls = (text) => {
            const found = new Set();
            const patterns = [
                /(https?:\/\/[^\s"'<>]+)/gi,
                /(www\.[^\s"'<>]+)/gi,
                /([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(\/[^\s"'<>]*)?/gi, // bare domains
            ];
            patterns.forEach((regex) => {
                for (const match of text.matchAll(regex)) {
                    let url = match[0];
                    if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
                    url = url.replace(/[,.;:]+$/, ''); // trim trailing punctuation
                    try {
                        const u = new URL(url);
                        u.hash = '';
                        found.add(u.toString().toLowerCase());
                    } catch {}
                }
            });
            return Array.from(found).slice(0, 8);
        };

        const analyzeLinkHeuristics = (raw) => {
            let parsed;
            const flags = [];
            let score = 0;
            try { parsed = new URL(raw); } catch { return { error: 'Invalid URL' }; }
            const hostRaw = parsed.hostname.toLowerCase();
            const host = hostRaw.replace(/^www\./, '');
            const hostLabel = host.split('.').slice(0, -1).join('.') || host.split('.')[0];
            const tld = host.split('.').pop() || '';
            const path = parsed.pathname || '/';

            if (parsed.protocol !== 'https:') { flags.push('Not using HTTPS'); score += 2; }
            if (looksLikeIp(host)) { flags.push('Bare IP instead of domain'); score += 2; }
            if (hasPunycode(host)) { flags.push('Unicode/punycode characters'); score += 2; }
            if (countDots(host) > 3) { flags.push('Deep subdomain'); score += 1; }
            if (suspiciousTlds.has(tld)) { flags.push(`Risky TLD .${tld}`); score += 2; }
            if (shortenerSet.has(host)) { flags.push('Link shortener (destination hidden)'); score += 2; }
            if (/[0-9]{5,}/.test(host)) { flags.push('Heavy numeric hostname'); score += 1; }
            if (parsed.port && !['80','443'].includes(parsed.port)) { flags.push(`Unusual port :${parsed.port}`); score += 1; }
            if (parsed.search.includes('base64') || /(data:|%2f|%40|%3d)/i.test(parsed.search)) { flags.push('Obfuscated parameters'); score += 1; }
            if (riskyPathWords.some((w) => path.toLowerCase().includes(w))) { flags.push('Suspicious keywords in path'); score += 2; }
            if (isObfuscatedPath(path)) { flags.push('Obfuscated path (random ID)'); score += 2; }
            if (hostLabel.length <= 6 && (/\d/.test(hostLabel) || !/[aeiou]/i.test(hostLabel))) { flags.push('Random-looking host name'); score += 2; }
            if (brandWords.some((w) => host.includes(w)) && !trustedAppleDomains.some((good) => host.endsWith(good))) { flags.push('Brand keyword without trusted domain'); score += 3; }
            if (suspiciousDomains.has(host)) { flags.push('Known suspicious domain'); score += 4; }
            const risk = riskLabel(score + flags.length);
            return { host, path, risk, flags };
        };

        const forceDangerLabels = new Set([
            'Astrology/reading solicitation',
            'Random follower selection lure',
            'Unsolicited outreach solicitation',
            'Zodiac prompt'
        ]);

        const hitDescriptions = {
            'Account/security language': 'Mentions account or security reviews that scammers often use.',
            'Urgency/deadline': 'Uses urgency or deadlines to force quick action.',
            'Payment request': 'Asks for money or payment methods.',
            'Apple brand targeting': 'References Apple services; verify the sender.',
            'Account lock threat': 'Threatens an account lock to prompt clicks.',
            'Payment update demand': 'Pushes a billing/payment update, common phish lure.',
            'Data deletion scare': 'Claims data or files will be deleted soon.',
            'Fake activation/case id': 'Uses activation/case IDs to seem official.',
            'Giveaway language': 'Giveaway or lottery wording used as bait.',
            'Contest with off-platform contact': 'Contest/winner lure that asks you to contact off-platform.',
            'Crypto/investment ask': 'Investment/crypto solicitations are common scam hooks.',
            'Authority/impersonation tone': 'Claims to be support/admin/official.',
            'Astrology/reading solicitation': 'Unsolicited ?reading? style outreach.',
            'Random follower selection lure': 'Says you were randomly selected; typical lure.',
            'Emotion bait language': 'Emotional appeals used to build quick trust.',
            'Generic shell / unavailable page': 'Generic profile wording that can hide identity.',
            'Unsolicited outreach solicitation': 'Cold outreach asking for engagement.',
            'Zodiac prompt': 'Zodiac prompts often show up in spammy outreach.',
            'Deactivated account lure': 'Claims the account is deactivated to prompt action.',
            'External contact handle': 'Pushes you to contact a handle (Telegram/WhatsApp/etc.).',
            'Third-party reach-out': 'Claims a friend/third party wants you to message them.',
            'Romance lure language': 'Romance/dating style language used as bait.'
        };
        const describeHit = (hit) => hitDescriptions[hit] || `Suspicious pattern: ${hit}`;


        const analyzeMessageHeuristics = (text) => {
            const patterns = [
                { regex: /(verify|suspend|locked|reset|appeal|violation|ticket)/i, label: 'Account/security language', weight: 2 },
                { regex: /(immediately|urgent|24 hours|right now|act now|final notice)/i, label: 'Urgency/deadline', weight: 2 },
                { regex: /(payment|deposit|wire|zelle|cash app|gift card|prepaid)/i, label: 'Payment request', weight: 2 },
                { regex: /(apple id|icloud|appleid|itunes|app store)/i, label: 'Apple brand targeting', weight: 3 },
                { regex: /(locked account|account will be locked|account lock)/i, label: 'Account lock threat', weight: 3 },
                { regex: /(update my payment details|update payment|billing update|payment declined)/i, label: 'Payment update demand', weight: 3 },
                { regex: /(files (?:deleted|erased)|data (?:deleted|erased)|cloud storage.*at risk|irreversible termination|media files.*lost)/i, label: 'Data deletion scare', weight: 3 },
                { regex: /(activation[- ]?id|activation id|case id)/i, label: 'Fake activation/case id', weight: 2 },
                { regex: /(giveaway|winner|prize|lottery|contest|survey reward|claim your prize)/i, label: 'Giveaway language', weight: 2 },
                { regex: /(giveaway|winner|prize|contest|lottery).*(telegram|whatsapp|signal|contact|dm)/i, label: 'Contest with off-platform contact', weight: 3 },
                { regex: /(crypto|usdt|bitcoin|investment|roi|forex)/i, label: 'Crypto/investment ask', weight: 2 },
                { regex: /(support agent|admin|representative|official)/i, label: 'Authority/impersonation tone', weight: 1 },
                { regex: /(deactivated account|deactivated profile|deactivated user)/i, label: 'Deactivated account lure', weight: 2 },
                { regex: /(reading|tarot|zodiac|signs|astrology)/i, label: 'Astrology/reading solicitation', weight: 4 },
                { regex: /(random from my followers|pick(?:ing)? random|consider you in a reading)/i, label: 'Random follower selection lure', weight: 4 },
                { regex: /(blessings|love and light)/i, label: 'Emotion bait language', weight: 3 },
                { regex: /(business chat|business chats|facebook user|page is unavailable on messenger|your privacy)/i, label: 'Generic shell / unavailable page', weight: 3 },
                { regex: /(thanks for supporting my page|would you like me to consider you)/i, label: 'Unsolicited outreach solicitation', weight: 3 },
                { regex: /(what.?s your zodiac|zodiac signs)/i, label: 'Zodiac prompt', weight: 3 },
                { regex: /(my friend (?:saw|found) your profile|too shy to message|could you dm (?:him|her)|message my friend|message her on)/i, label: 'Third-party reach-out', weight: 3 },
                { regex: /(you.?re (?:exactly|just) my type|you look like my type|romance|date you|soulmate|my type lol)/i, label: 'Romance lure language', weight: 3 },
                { regex: /(telegram|t\\.me|whatsapp|signal|snapchat|discord|line)[^\\w]?(?:@|id[:\\s]*)?[A-Za-z0-9_.-]{4,}/i, label: 'External contact handle', weight: 3 },
                { regex: /@(?:[A-Za-z0-9_.-]{4,})/i, label: 'External contact handle', weight: 2 }
            ];
            let score = 0;
            const hits = [];
            const lower = text.toLowerCase();
            patterns.forEach((p) => { if (p.regex.test(lower)) { score += p.weight; hits.push(p.label); } });
            const risk = score >= 4 ? 'Dangerous' : score >= 2 ? 'Caution' : 'Safe';
            return { risk, hits };
        };

        const setVerdict = (risk, reasons, confidence = null, guidance = '') => {
            const color = risk === 'Dangerous' ? '#ff6b6b' : risk === 'Caution' ? '#f5c862' : '#5be18a';
            verdictPill.textContent = risk;
            verdictPill.style.background = `${color}20`;
            verdictPill.style.border = `1px solid ${color}55`;
            verdictPill.style.color = color;
            const confHtml = confidence ? `<div class="node-summary">Confidence: ${Math.round(confidence * 100)}%</div>` : '';
            const guideHtml = guidance ? `<div class="node-summary">${guidance}</div>` : '';
            const listHtml = (reasons && reasons.length) ? `<ul class="flag-list">${reasons.map((r) => `<li>${r}</li>`).join('')}</ul>` : 'No clear issues detected. Still be cautious.';
            reasonList.innerHTML = confHtml + guideHtml + listHtml;
        };

        const renderLinks = (items) => {
            if (!items || !items.length) { linksBlock.textContent = 'No links found.'; return; }
            linksBlock.innerHTML = items.map((i) => `<div class="node-summary" style="margin-bottom:8px;"><strong>${i.risk}</strong><br>${i.url}<br>${i.flags?.length ? i.flags.join('; ') : 'No flags'}</div>`).join('');
        };

        const renderOsint = (items) => {
            if (!items || !items.length) { osintBlock.textContent = 'No OSINT lookups yet.'; return; }
            osintBlock.innerHTML = items.map((i) => {
                const phish = i.phish === true ? 'Flagged in phish feed' : i.phish === false ? 'Not in phish feed' : i.phish;
                const urlhaus = i.urlhaus === true ? 'Listed in URLHaus' : i.urlhaus === false ? 'Not in URLHaus' : i.urlhaus;
                return `<div class="node-summary" style="margin-bottom:8px;">${i.url}<br>${[phish, urlhaus].filter(Boolean).join(' | ')}</div>`;
            }).join('');
        };

        const loadImageFlexible = async (file) => {
            try { return await createImageBitmap(file); }
            catch {
                const blobUrl = URL.createObjectURL(file);
                const img = await new Promise((resolve, reject) => {
                    const el = new Image();
                    el.onload = () => resolve(el);
                    el.onerror = reject;
                    el.src = blobUrl;
                });
                URL.revokeObjectURL(blobUrl);
                return img;
            }
        };

        const toCanvas = (source, { maxDim = 1200, highContrast = false, threshold = 175, invert = false } = {}) => {
            const canvas = document.createElement('canvas');
            let { width, height } = source;
            const scale = Math.min(1, maxDim / Math.max(width, height));
            if (scale < 1) { width = Math.floor(width * scale); height = Math.floor(height * scale); }
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(source, 0, 0, width, height);
            if (highContrast) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const dataArr = imageData.data;
                for (let i = 0; i < dataArr.length; i += 4) {
                    const r = dataArr[i], g = dataArr[i + 1], b = dataArr[i + 2];
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    const val = gray > threshold ? 255 : 0;
                    const finalVal = invert ? 255 - val : val;
                    dataArr[i] = dataArr[i + 1] = dataArr[i + 2] = finalVal;
                }
                ctx.putImageData(imageData, 0, 0);
            }
            return canvas;
        };

        const recognizeCanvas = async (canvas) => {
            const { data } = await Tesseract.recognize(canvas, 'eng', {
                logger: () => {},
                tessedit_pageseg_mode: 6,
                preserve_interword_spaces: 1
            });
            return (data?.text || '').trim();
        };

        const runOcr = async (file, preferPhoto = false) => {
            const source = await loadImageFlexible(file);
            const basePasses = [
                { maxDim: 1200, highContrast: false, threshold: 175, minLen: 12 },
                { maxDim: 1100, highContrast: true, threshold: 155, invert: false, minLen: 10 },
                { maxDim: 900, highContrast: true, threshold: 150, invert: true, minLen: 6 },
                { maxDim: 700, highContrast: true, threshold: 140, invert: true, minLen: 4 }
            ];
            const photoPasses = preferPhoto ? [
                { maxDim: 1600, highContrast: true, threshold: 140, invert: false, minLen: 8 },
                { maxDim: 1600, highContrast: true, threshold: 130, invert: true, minLen: 8 },
            ] : [];
            const passes = [...photoPasses, ...basePasses];
            for (const pass of passes) {
                try {
                    const canvas = toCanvas(source, pass);
                    const txt = await recognizeCanvas(canvas);
                    if (txt.length >= (pass.minLen || 6)) return txt;
                } catch {}
            }
            return '';
        };

        const fetchWithTimeout = async (url, options = {}, ms = 5000) => {
            const ctrl = new AbortController();
            const id = setTimeout(() => ctrl.abort(), ms);
            try {
                return await fetch(url, { ...options, signal: ctrl.signal });
            } finally {
                clearTimeout(id);
            }
        };

        const hostCache = new Map(); // hostname -> { phish, urlhaus }

        const setOsintProgress = (visible, pct = 0, text = '') => {
            if (!osintProgress) return;
            osintProgress.style.display = visible ? 'block' : 'none';
            if (osintProgressBar) osintProgressBar.style.width = `${Math.round(pct * 100)}%`;
            if (osintProgressText && text) osintProgressText.textContent = text;
        };

        const fetchOsintForLinks = async (urls) => {
            const limited = urls.slice(0, 3); // cap lookups to reduce wait
            let done = 0;
            const tasks = limited.map(async (url) => {
                try {
                    const host = new URL(url).hostname.toLowerCase();
                    if (hostCache.has(host)) return { url, ...hostCache.get(host) };
                    const resp = await fetchWithTimeout('/api/osint/link', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ url })
                    }, 5000);
                    if (!resp?.ok) throw new Error('HTTP ' + (resp?.status || ''));
                    const data = await resp.json();
                    const phish = data?.sources?.phishFeed;
                    const urlhaus = data?.sources?.urlhaus;
                    const record = {
                        phish: phish?.flagged ?? phish?.error,
                        urlhaus: urlhaus?.listed ?? urlhaus?.error
                    };
                    hostCache.set(host, record);
                    done += 1;
                    setOsintProgress(true, done / limited.length, `OSINT ${done}/${limited.length}...`);
                    return { url, ...record };
                } catch (e) {
                    done += 1;
                    setOsintProgress(true, done / limited.length, `OSINT ${done}/${limited.length}...`);
                    return { url, phish: 'timeout/failed', urlhaus: 'timeout/failed' };
                }
            });
            const res = await Promise.all(tasks);
            setOsintProgress(false, 1, '');
            return res;
        };

        const combineRisk = (msgRisk, linkFindings, osintFindings, hasTextHits, msgHits) => {
        const computeConfidence = (risk, reasonsCount, osintCount = 0) => {
            let base = risk === 'Dangerous' ? 0.9 : risk === 'Caution' ? 0.78 : 0.7;
            if (reasonsCount > 3) base += 0.05;
            if (osintCount > 0) base += 0.05;
            if (reasonsCount === 0) base -= 0.2;
            return Math.min(0.99, Math.max(0.3, base));
        };

            const osintHit = osintFindings?.some((o) => o.phish === true || o.urlhaus === true);
            const linkHigh = linkFindings?.some((l) => l.risk === 'Dangerous');
            const forceDanger = msgHits?.some((h) => forceDangerLabels.has(h));
            if (osintHit || linkHigh) return 'Dangerous';
            if (msgRisk === 'Dangerous' || forceDanger) return 'Dangerous';
            const linkWarn = linkFindings?.some((l) => l.risk === 'Caution');
            if (msgRisk === 'Caution' || linkWarn) return 'Caution';
            if (hasTextHits) return 'Caution';
            return 'Safe';
        };

        const analyzeTextFlow = async (text, setStatus, origin = 'text', runOsint = true) => {
            setStatus('Scanning...');
            const urls = extractUrls(text);
            const linkFindings = urls.map((url) => {
                const res = analyzeLinkHeuristics(url);
                return { url, risk: res.risk, flags: res.flags || [] };
            });
            const msgFinding = analyzeMessageHeuristics(text);
            let osintFindings = [];
            if (runOsint && urls.length) {
                setStatus('Running OSINT lookups (timeout ~5s)...');
                osintFindings = await fetchOsintForLinks(urls);
            }
            const reasons = [];
            if (msgFinding.hits.length) {
                const friendly = msgFinding.hits.map((h) => `Text signal: ${describeHit(h)}`);
                reasons.push(...friendly);
            }
            linkFindings.forEach((l) => {
                const flagText = l.flags?.length ? ` | Flags: ${l.flags.join(', ')}` : '';
                reasons.push(`Link ${l.risk}: ${l.url}${flagText}`);
            });
            if (osintFindings.length) {
                osintFindings.forEach((o) => {
                    if (o.phish === true || o.urlhaus === true) reasons.push(`OSINT: ${o.url} flagged in public feeds.`);
                });
            }
            let finalRisk = combineRisk(msgFinding.risk, linkFindings, osintFindings, msgFinding.hits.length > 0, msgFinding.hits);
            if (origin === 'screenshot') {
                const hasSignals = urls.length || msgFinding.hits.length || text.trim().length > 0;
                if (finalRisk === 'Safe' && hasSignals) {
                    finalRisk = 'Caution';
                    reasons.push('Screenshot scan: treated as caution to avoid false negatives.');
                } else if (finalRisk === 'Safe' && !hasSignals) {
                    finalRisk = 'Caution';
                    reasons.push('Screenshot scan: no text detected; treat with caution.');
                }
            }
            const guidance = finalRisk === 'Dangerous' ? 'Do not click. Verify with the official site or app.' : finalRisk === 'Caution' ? 'Be cautious. Verify sender and avoid signing in via this link.' : 'Looks okay, but stay cautious. Avoid entering credentials if unsure.';
            const confidence = computeConfidence(finalRisk, reasons.length, osintFindings.length);
            setVerdict(finalRisk, reasons, confidence, guidance);
            renderLinks(linkFindings);
            renderOsint(osintFindings);
            if (ocrPreview) {
                const safeText = text ? text.replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'No OCR text.';
                ocrPreview.innerHTML = `<div class="node-summary" style="white-space:pre-wrap;">${safeText}</div>`;
            }
            setStatus('Done');
        };

                scanText?.addEventListener('click', async () => {
            const text = (textInput?.value || '').trim();
            if (!text) { textStatus.textContent = 'Paste something to scan.'; return; }
            const runOsint = (document.getElementById('osintToggle')?.checked !== false);
            await analyzeTextFlow(text, (msg) => textStatus.textContent = msg, 'text', runOsint);
        });

        scanShot?.addEventListener('click', async () => {
            const file = shotInput?.files?.[0];
            if (!file) { shotStatus.textContent = 'Choose a screenshot first.'; return; }
            shotStatus.textContent = 'Running OCR locally...';
            try {
                const preferPhoto = (document.getElementById('shotPhotoMode')?.checked === true);
                let ocrText = await runOcr(file, preferPhoto);
                if (!ocrText) {
                    shotStatus.textContent = 'OCR failed on this image. Try a closer crop or brighter screenshot.';
                    return;
                }
                const runOsintShot = (document.getElementById('osintToggleShot')?.checked !== false);
                await analyzeTextFlow(ocrText, (msg) => shotStatus.textContent = msg, 'screenshot', runOsintShot);
                shotStatus.textContent = 'Done';
            } catch (e) {
                shotStatus.textContent = 'OCR failed. Try a closer crop or brighter screenshot.';
            }
        });

        // scroll helper
        const scrollButtons = document.querySelectorAll('[data-target]');
        scrollButtons.forEach((btn) => {
            btn.addEventListener('click', () => {
                const target = document.querySelector(btn.getAttribute('data-target'));
                if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });
    })();
    </script>
</body>
</html>
