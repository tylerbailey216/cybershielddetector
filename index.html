<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phishing &amp; Impersonation Guard</title>
    <link rel="stylesheet" href="./public/styles.css?v=tsb39">
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://unpkg.com/@zxing/library@0.19.1/umd/index.min.js"></script>
    <style>
        .progress-container {
            margin-top: 8px;
            display: none;
        }
        .progress-container.active {
            display: block;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #5be18a, #4ade80);
            transition: width 0.3s ease;
            border-radius: 3px;
            width: 0%;
        }
        .processing-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #5be18a;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* NUCLEAR OPTION - Force grid cells to contain their content */
        .addon-grid {
            display: grid !important;
        }
        
        .addon-card {
            min-width: 0 !important;
            overflow: hidden !important;
        }
        
        .addon-card > * {
            max-width: 100% !important;
            overflow: hidden !important;
        }
        
        /* Fix text formatting and prevent overlap - STRONGER ISOLATION */
        .results-wrapper {
            display: block !important;
            width: 100% !important;
            overflow: hidden !important;
            min-width: 0 !important;
        }
        
        .results-wrapper #linksBlock,
        .results-wrapper #osintBlock,
        .results-wrapper #ocrPreview,
        .results-wrapper #reasonList {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            white-space: normal !important;
            max-width: 100% !important;
            display: block !important;
            min-width: 0 !important;
        }
        
        .results-wrapper #linksBlock > div,
        .results-wrapper #osintBlock > div {
            padding: 10px !important;
            margin-bottom: 10px !important;
            background: rgba(0,0,0,0.2) !important;
            border-radius: 8px !important;
            border: 1px solid rgba(255,255,255,0.06) !important;
            display: block !important;
            width: 100% !important;
            box-sizing: border-box !important;
            min-width: 0 !important;
            overflow: hidden !important;
        }
        
        .results-wrapper #linksBlock strong {
            display: block !important;
            margin-bottom: 4px !important;
            font-size: 14px !important;
            overflow: hidden !important;
        }
        
        .results-wrapper #linksBlock .node-summary,
        .results-wrapper #osintBlock .node-summary {
            font-size: 12px !important;
            line-height: 1.6 !important;
            color: rgba(245,247,250,0.85) !important;
            word-break: break-all !important;
            display: block !important;
            width: 100% !important;
            overflow-wrap: anywhere !important;
        }
        
        .results-wrapper #ocrPreview {
            max-height: 150px !important;
            overflow-y: auto !important;
            padding: 8px !important;
            background: rgba(0,0,0,0.2) !important;
            border-radius: 8px !important;
            font-family: monospace !important;
            font-size: 12px !important;
            line-height: 1.6 !important;
            display: block !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .photo-mode-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0 2px;
            color: #f5f7fa;
            font-size: 14px;
            line-height: 1.4;
            overflow: visible;
            flex-wrap: wrap;
            width: 100%;
        }
        .photo-mode-row span {
            color: inherit;
            flex: 1 1 auto;
            min-width: 0;
            white-space: normal;
        }
        .photo-mode-note {
            color: #d8f5ff;
            font-size: 13px;
            margin: 0 0 8px 0;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <main class="layout">
        <section class="hero hero-shell">
            <div class="hero-content">
                <p class="node-summary">Drop a link, message, or screenshot. We tell you if it looks risky - no clicks needed.</p>
                <ul class="hero-highlights">
                    <li>OCR screenshot scan (links stay non-clickable)</li>
                    <li>OSINT feeds: phish.sinking.yachts, URLHaus</li>
                    <li>Brand impersonation + obfuscated path detection</li>
                </ul>
            </div>
            <div class="hero-visual">
                <div class="grid-lines"></div>
                <div class="hero-logo-wrap">
                    <img src="./public/cybershieldlogo.png" alt="Cyber Shield" class="hero-logo-large">
                </div>
                <div class="floating-badges">
                    <div class="floating-badge">Never click to check</div>
                    <div class="floating-badge">Checks public threat lists</div>
                    <div class="floating-badge">Screenshot scan (non-clickable links)</div>
                </div>
            </div>
        </section>

        <section class="tree-card" id="guard">
            <div class="tree-header">
                <div>
                    <p class="node-path">Safety guard</p>
                    <h2>Phishing &amp; Impersonation Guard</h2>
                    <p class="node-summary">Paste text or drop a screenshot. We extract links, run heuristics + OSINT, and give a clear verdict.</p>
                </div>
            </div>
            <div class="node-body">
                <div class="addon-grid">
                    <div class="addon-card">
                        <h3>Text / Link check</h3>
                        <p class="node-summary">Paste a DM, comment, or email text. Links stay non-clickable.</p>
                        <textarea id="textInput" rows="6" placeholder="Paste the message or link..."></textarea>
                        <button class="ghost" type="button" id="scanText">Scan text</button>
                        <div id="textStatus" class="node-summary">Idle</div>
                        <div id="textProgress" class="progress-container">
                            <div class="progress-bar"><div class="progress-fill" id="textProgressFill"></div></div>
                        </div>
                    </div>
                    <div class="addon-card">
                    <h3>Screenshot scan</h3>
                    <p class="node-summary">Upload PNG/JPG. OCR runs locally; extracted links are shown as text.</p>
                    <input type="file" id="shotInput" accept="image/png,image/jpeg">
                    <label class="photo-mode-row">
                        <input type="checkbox" id="shotPhotoMode" style="flex:0 0 auto;">
                        <span>Photo mode (better for camera pictures of a screen)</span>
                    </label>
                    <div class="photo-mode-note">Photo mode boosts OCR for phone photos of screens.</div>
                    <p class="node-summary" style="margin:2px 0 10px;">Tip: for best results, hold steady, avoid glare, and fill the frame; screenshots are still most accurate.</p>
                    <button class="ghost" type="button" id="scanShot">Scan screenshot</button>
                    <div id="shotStatus" class="node-summary">Idle</div>
                    <div id="shotProgress" class="progress-container">
                        <div class="progress-bar"><div class="progress-fill" id="shotProgressFill"></div></div>
                    </div>
                </div>
                <div class="addon-card">
                    <h3>QR / payload scan</h3>
                    <p class="node-summary">Upload a QR image. We decode it locally and scan the payload without opening it.</p>
                    <input type="file" id="qrInput" accept="image/png,image/jpeg">
                    <button class="ghost" type="button" id="scanQr">Scan QR</button>
                    <div id="qrStatus" class="node-summary">Idle</div>
                </div>
                <div class="addon-card">
                    <h3>Verdict</h3>
                    <div id="verdictPill" class="risk-pill" style="background:#f5c86220;border:1px solid #f5c86255;color:#f5c862;">Pending</div>
                    <div class="results-wrapper">
                            <div id="reasonList" class="node-summary" style="margin-top:10px;">No scan yet.</div>
                        </div>
                    </div>
                    <div class="addon-card">
                        <h3>Extracted links</h3>
                        <div class="results-wrapper">
                            <div id="linksBlock" class="node-summary">None yet.</div>
                        </div>
                    </div>
                    <div class="addon-card">
                        <h3>OSINT checks</h3>
                        <div class="results-wrapper">
                            <div id="osintBlock" class="node-summary">None yet.</div>
                        </div>
                    </div>
                    <div class="addon-card">
                        <h3>OCR text (preview)</h3>
                        <div class="results-wrapper">
                            <div id="ocrPreview" class="node-summary">No OCR text yet.</div>
                        </div>
                        <p class="node-summary" style="margin-top:8px;">OCR = Optical Character Recognition. It reads text inside your screenshot so you can see links and flags without ever clicking them.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="privacy-note">
            Privacy: OCR and heuristics run in your browser. Link intel hits public feeds (phish.sinking.yachts, URLHaus) only when online with the local server.
        </section>

        <section class="tree-card">
            <div class="tree-header">
                <div>
                    <p class="node-path">Support</p>
                    <h2>If this helped you</h2>
                    <p class="node-summary">Donations are always welcome and much appreciated but never required. Thank you for your support!</p>
                </div>
            </div>
            <div class="node-body" style="display:flex; flex-direction:column; gap:14px; align-items:center;">
                <div class="support-actions">
                    <a class="pill-link" href="https://www.paypal.me/garinbailey1" target="_blank" rel="noopener">
                        <img src="./public/support-paypal.svg" alt="PayPal">
                        <span>@garinbailey1</span>
                    </a>
                    <a class="pill-link" href="https://cash.app/$gbailey216" target="_blank" rel="noopener">
                        <img src="./public/Square_Cash_app_logo.svg" alt="Cash App">
                        <span>$gbailey216</span>
                    </a>
                </div>
            </div>
        </section>

        <section class="tree-card">
            <div class="tree-header">
                <div>
                    <p class="node-path">About</p>
                    <h2>Who is Behind the Cyber Shield?</h2>
                    <p class="node-summary">Built by Garin Bailey, Senior IT Specialist (field-tested support, no data collection).</p>
                </div>
            </div>
            <div class="node-body" style="display:flex; flex-direction:column; gap:12px; align-items:center;">
                <p class="support-copy">I help people solve everyday tech problems without collecting their data. This tool runs in your browser only and is not a replacement for your company IT policies.</p>
                <div class="support-actions" style="flex-direction:row; align-items:center; justify-content:center; gap:10px;">
                    <span class="node-summary">Connect:</span>
                    <a class="pill-link" href="https://www.linkedin.com/in/gbailey216/" target="_blank" rel="noopener">
                        <img src="./public/LinkedIn_icon.svg" alt="LinkedIn">
                        <span>LinkedIn</span>
                    </a>
                </div>
            </div>
        </section>

        <section class="tree-card counter-card" id="visit-counter">
            <div class="tree-header">
                <div>
                    <p class="node-path">Site stats</p>
                    <h2>Global visit counter</h2>
                    <p class="node-summary">Public count of visits across all users.</p>
                </div>
            </div>
            <div class="node-body">
                <div class="counter-shell" role="status" aria-live="polite">
                    <div class="counter-label">Global visits</div>
                    <div class="counter-display">
                        <span id="visitCounter" class="counter-digits">0000000000</span>
                    </div>
                    <div id="visitCounterNote" class="counter-sub">Updating...</div>
                </div>
            </div>
        </section>
    </main>

    <script>
    (() => {
        const verdictPill = document.getElementById('verdictPill');
        const reasonList = document.getElementById('reasonList');
        const linksBlock = document.getElementById('linksBlock');
        const osintBlock = document.getElementById('osintBlock');
        const ocrPreview = document.getElementById('ocrPreview');
        const textInput = document.getElementById('textInput');
        const scanText = document.getElementById('scanText');
        const textStatus = document.getElementById('textStatus');
        const textProgress = document.getElementById('textProgress');
        const textProgressFill = document.getElementById('textProgressFill');
        const shotInput = document.getElementById('shotInput');
        const scanShot = document.getElementById('scanShot');
        const shotStatus = document.getElementById('shotStatus');
        const shotProgress = document.getElementById('shotProgress');
        const shotProgressFill = document.getElementById('shotProgressFill');
        const qrInput = document.getElementById('qrInput');
        const scanQr = document.getElementById('scanQr');
        const qrStatus = document.getElementById('qrStatus');
        const visitCounter = document.getElementById('visitCounter');
        const visitCounterNote = document.getElementById('visitCounterNote');

        const updateVisitCounter = (value) => {
            if (!visitCounter) return;
            const digits = String(value ?? 0).padStart(10, '0');
            visitCounter.textContent = digits;
        };

        const fetchVisitCounter = async () => {
            if (!visitCounter) return;
            try {
                const response = await fetch('https://api.counterapi.dev/v1/tylerbailey216-cybershielddetector/visits/up', { cache: 'no-store' });
                if (!response.ok) throw new Error('Counter unavailable');
                const data = await response.json();
                if (typeof data?.count === 'number') {
                    updateVisitCounter(data.count);
                    if (visitCounterNote) visitCounterNote.textContent = 'Updated just now.';
                } else if (visitCounterNote) {
                    visitCounterNote.textContent = 'Counter unavailable.';
                }
            } catch (e) {
                if (visitCounterNote) visitCounterNote.textContent = 'Counter unavailable (offline).';
            }
        };

        fetchVisitCounter();

        const suspiciousTlds = new Set(['zip','ru','cn','tk','ml','gq','ga','cf','work','top','quest','click','country','rest','cam']);
        const shortenerSet = new Set(['bit.ly','tinyurl.com','t.co','goo.gl','ow.ly','buff.ly','is.gd','rebrand.ly','cutt.ly','shorte.st','lnkd.in','bl.ink']);
        const riskyPathWords = ['login','signin','verify','account','secure','update','billing','invoice','prize','gift','bonus','free','btc','crypto','usdt','wallet','token','auth','reset','payment','appleid','icloud','account-lock','lock-account','reactivate','suspend'];
        const brandWords = ['apple','appleid','icloud','appstore','itunes','meta','facebook','instagram','whatsapp','paypal','bank','usps','ups'];
        const trustedAppleDomains = ['apple.com','icloud.com','appleid.apple.com'];
        const suspiciousDomains = new Set(['brainstormlabserver.com','acftop.com','muet.brainstormlabserver.com']);

        const forceDangerLabels = new Set([
            'Astrology/reading solicitation',
            'Random follower selection lure',
            'Unsolicited outreach solicitation',
            'Zodiac prompt',
            'Suspicious attachment type',
            'Double-extension attachment',
            'Macro enable prompt'
        ]);

        const hitDescriptions = {
            'Account/security language': 'Mentions account or security reviews that scammers often use.',
            'Urgency/deadline': 'Uses urgency or deadlines to force quick action.',
            'Payment request': 'Asks for money or payment methods.',
            'Apple brand targeting': 'References Apple services; verify the sender.',
            'Account lock threat': 'Threatens an account lock to prompt clicks.',
            'Payment update demand': 'Pushes a billing/payment update, common phish lure.',
            'Data deletion scare': 'Claims data or files will be deleted soon.',
            'Fake activation/case id': 'Uses activation/case IDs to seem official.',
            'Giveaway language': 'Giveaway or lottery wording used as bait.',
            'Contest with off-platform contact': 'Contest/winner lure that asks you to contact off-platform.',
            'Crypto/investment ask': 'Investment/crypto solicitations are common scam hooks.',
            'Authority/impersonation tone': 'Claims to be support/admin/official.',
            'Astrology/reading solicitation': 'Unsolicited reading style outreach.',
            'Random follower selection lure': 'Says you were randomly selected; typical lure.',
            'Emotion bait language': 'Emotional appeals used to build quick trust.',
            'Generic shell / unavailable page': 'Generic profile wording that can hide identity.',
            'Unsolicited outreach solicitation': 'Cold outreach asking for engagement.',
            'Zodiac prompt': 'Zodiac prompts often show up in spammy outreach.',
            'Deactivated account lure': 'Claims the account is deactivated to prompt action.',
            'External contact handle': 'Pushes you to contact a handle (Telegram/WhatsApp/etc.).',
            'Third-party reach-out': 'Claims a friend/third party wants you to message them.',
            'Romance lure language': 'Romance/dating style language used as bait.',
            'Attachment download instruction': 'Asks you to open/download an attachment; verify the sender.',
            'Suspicious attachment type': 'Executable or HTML attachment types are commonly used in phishing.',
            'Double-extension attachment': 'Filename uses double extensions to hide executable files.',
            'Macro enable prompt': 'Asks you to enable macros/content, a common malware trick.',
            'Password-protected attachment': 'Password-protected attachments are used to evade scanners.',
            'Update/installer lure': 'Update/installer language used to push a download or restart.',
            'IT impersonation': 'Claims to be internal IT/helpdesk to gain trust.',
            'Credential prompt': 'Asks you to sign in or verify your identity.',
            'Mailbox quota pressure': 'Claims your mailbox is full to push a login.',
            'Secure message lure': 'Secure/encrypted message prompts can hide phishing.',
            'Document share lure': 'Shared document language used to lure clicks.',
            'Invoice/payment lure': 'Invoice or payment language used in business email compromise.',
            'Security alert lure': 'Suspicious login/new device alerts used to prompt action.'
        };

        const riskLabel = (score) => score >= 4 ? 'Dangerous' : score >= 2 ? 'Caution' : 'Safe';
        const looksLikeIp = (host) => /^(\d{1,3}\.){3}\d{1,3}$/.test(host);
        const hasPunycode = (host) => host.includes('xn--') || /[^\x00-\x7F]/.test(host);
        const countDots = (host) => (host.match(/\./g) || []).length;
        
        const isObfuscatedPath = (path) => {
            const trimmed = (path || '/').replace(/^\/+/, '');
            if (!trimmed) return false;
            if (trimmed.length >= 20 && /^[A-Za-z0-9/+_.-]+$/.test(trimmed)) {
                const hasLetters = /[A-Za-z]/.test(trimmed);
                const hasDigits = /\d/.test(trimmed);
                const hasSeparators = /[-_/?.=&]/.test(trimmed);
                if (hasLetters && hasDigits && !hasSeparators) return true;
            }
            return false;
        };

        const extractUrls = (text) => {
    if (!text) return [];

    // Normalize line breaks
    let working = text.replace(/\r\n/g, '\n');

    // Join URLs that wrapped onto the next line, e.g.
    // "facebook-help.social" + newline + "/path/file.html"
    working = working.replace(
        /(\bhttps?:\/\/[^\s"'<>]+|\bwww\.[^\s"'<>]+|\b[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\s*[\n\r]+\s*(\/[^\s"'<>]+)/gi,
        '$1$2'
    );

    const found = new Set();

    const patterns = [
        // Full URLs with protocol
        /(https?:\/\/[^\s"'<>]+)/gi,

        // www. URLs
        /(www\.[^\s"'<>]+)/gi,

        // Bare domains like "example.com" or "example.com/path", but only
        // when they are at the start of the line or preceded by whitespace,
        // "(" or ">" so we don't accidentally treat URL path segments as
        // new domains.
        /(^|[\s(>])([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(\/[^\s"'<>]*)?/gi,
    ];

    patterns.forEach((regex, idx) => {
        for (const match of working.matchAll(regex)) {
            let url;

            if (idx === 2) {
                // For the bare-domain pattern, the domain is group 2 and
                // the optional path is group 3.
                url = match[2] + (match[3] || '');
            } else {
                url = match[0];
            }

            if (!/^https?:\/\//i.test(url)) {
                url = 'https://' + url;
            }

            // Trim trailing punctuation that often sticks to URLs
            url = url.replace(/[,.;:]+$/, '');

            try {
                const u = new URL(url);
                u.hash = '';
                found.add(u.toString().toLowerCase());
            } catch {
                // Ignore invalid URLs
            }
        }
    });

    return Array.from(found).slice(0, 8);
};


        const analyzeLinkHeuristics = (raw) => {
            let parsed;
            const flags = [];
            let score = 0;
            try { parsed = new URL(raw); } catch { return { error: 'Invalid URL' }; }
            const hostRaw = parsed.hostname.toLowerCase();
            const host = hostRaw.replace(/^www\./, '');
            const hostLabel = host.split('.').slice(0, -1).join('.') || host.split('.')[0];
            const tld = host.split('.').pop() || '';
            const path = parsed.pathname || '/';

            if (parsed.protocol !== 'https:') { flags.push('Not using HTTPS'); score += 2; }
            if (looksLikeIp(host)) { flags.push('Bare IP instead of domain'); score += 2; }
            if (hasPunycode(host)) { flags.push('Unicode/punycode characters'); score += 2; }
            if (countDots(host) > 3) { flags.push('Deep subdomain'); score += 1; }
            if (suspiciousTlds.has(tld)) { flags.push(`Risky TLD .${tld}`); score += 2; }
            if (shortenerSet.has(host)) { flags.push('Link shortener (destination hidden)'); score += 2; }
            if (/[0-9]{5,}/.test(host)) { flags.push('Heavy numeric hostname'); score += 1; }
            if (parsed.port && !['80','443'].includes(parsed.port)) { flags.push(`Unusual port :${parsed.port}`); score += 1; }
            if (parsed.search.includes('base64') || /(data:|%2f|%40|%3d)/i.test(parsed.search)) { flags.push('Obfuscated parameters'); score += 1; }
            if (riskyPathWords.some((w) => path.toLowerCase().includes(w))) { flags.push('Suspicious keywords in path'); score += 2; }
            if (isObfuscatedPath(path)) { flags.push('Obfuscated path (random ID)'); score += 2; }
            if (hostLabel.length <= 6 && (/\d/.test(hostLabel) || !/[aeiou]/i.test(hostLabel))) { flags.push('Random-looking host name'); score += 2; }
            if (brandWords.some((w) => host.includes(w)) && !trustedAppleDomains.some((good) => host.endsWith(good))) { flags.push('Brand keyword without trusted domain'); score += 3; }
            if (suspiciousDomains.has(host)) { flags.push('Known suspicious domain'); score += 4; }
            const risk = riskLabel(score + flags.length);
            return { url: raw, host, path, risk, flags, score };
        };

        const describeHit = (hit) => hitDescriptions[hit] || `Suspicious pattern: ${hit}`;

        const analyzeMessageHeuristics = (text) => {
            const patterns = [
                { regex: /(verify|suspend|locked|reset|appeal|violation|ticket)/i, label: 'Account/security language', weight: 2 },
                { regex: /(immediately|urgent|24 hours|right now|act now|final notice)/i, label: 'Urgency/deadline', weight: 2 },
                { regex: /(payment|deposit|wire|zelle|cash app|gift card|prepaid)/i, label: 'Payment request', weight: 2 },
                { regex: /(apple id|icloud|appleid|itunes|app store)/i, label: 'Apple brand targeting', weight: 3 },
                { regex: /(locked account|account will be locked|account lock)/i, label: 'Account lock threat', weight: 3 },
                { regex: /(update my payment details|update payment|billing update|payment declined)/i, label: 'Payment update demand', weight: 3 },
                { regex: /(attached file|attachment|open the attachment|download the attachment|click the attached|attached document|see attached|attached invoice)/i, label: 'Attachment download instruction', weight: 3 },
                { regex: /\b[\w-]+\.(pdf|docx?|xlsx?|pptx?|jpg|png)\.(exe|js|vbs|scr|bat|cmd|ps1|lnk)\b/i, label: 'Double-extension attachment', weight: 4 },
                { regex: /\b[\w-]+\.(html?|msi|exe|zip|iso|img|js|vbs|ps1|bat|cmd|lnk|scr|jar|cab|reg|docm|xlsm|pptm|rtf|one)\b/i, label: 'Suspicious attachment type', weight: 4 },
                { regex: /(enable content|enable editing|macros? disabled|protected view|security warning|click enable)/i, label: 'Macro enable prompt', weight: 4 },
                { regex: /(password (?:is|for)|zip password|encrypted attachment|password-protected)/i, label: 'Password-protected attachment', weight: 3 },
                { regex: /(sign in to view|login to view|verify your identity|reauthenticate|confirm your password)/i, label: 'Credential prompt', weight: 3 },
                { regex: /(mailbox.*full|storage (?:full|quota)|exceed(?:ed)? quota|email account will be deleted)/i, label: 'Mailbox quota pressure', weight: 3 },
                { regex: /(secure message|encrypted message|view secure|securely shared|confidential message)/i, label: 'Secure message lure', weight: 2 },
                { regex: /(sharepoint|one ?drive|google drive|dropbox|icloud drive|document shared|shared document|shared file)/i, label: 'Document share lure', weight: 2 },
                { regex: /(windows update|update issue|installer|install the|known issue rollback|kir|restart to complete|microsoft windows installer|security update)/i, label: 'Update/installer lure', weight: 2 },
                { regex: /(internal it|it alert|it department|helpdesk|service desk|it support|sysadmin)/i, label: 'IT impersonation', weight: 2 },
                { regex: /(unusual activity|suspicious sign-in|new sign-in|new device|login attempt)/i, label: 'Security alert lure', weight: 2 },
                { regex: /(invoice|remittance|payment due|past due|overdue|statement|purchase order|po number|wire transfer|ach|bank details|routing number)/i, label: 'Invoice/payment lure', weight: 2 },
                { regex: /(files (?:deleted|erased)|data (?:deleted|erased)|cloud storage.*at risk|irreversible termination|media files.*lost)/i, label: 'Data deletion scare', weight: 3 },
                { regex: /(activation[- ]?id|activation id|case id)/i, label: 'Fake activation/case id', weight: 2 },
                { regex: /(giveaway|winner|prize|lottery|contest|survey reward|claim your prize)/i, label: 'Giveaway language', weight: 2 },
                { regex: /(giveaway|winner|prize|contest|lottery).*(telegram|whatsapp|signal|contact|dm)/i, label: 'Contest with off-platform contact', weight: 3 },
                { regex: /(crypto|usdt|bitcoin|investment|roi|forex)/i, label: 'Crypto/investment ask', weight: 2 },
                { regex: /(support agent|admin|representative|official)/i, label: 'Authority/impersonation tone', weight: 1 },
                { regex: /(deactivated account|deactivated profile|deactivated user)/i, label: 'Deactivated account lure', weight: 2 },
                { regex: /(reading|tarot|zodiac|signs|astrology)/i, label: 'Astrology/reading solicitation', weight: 4 },
                { regex: /(random from my followers|pick(?:ing)? random|consider you in a reading)/i, label: 'Random follower selection lure', weight: 4 },
                { regex: /(blessings|love and light)/i, label: 'Emotion bait language', weight: 3 },
                { regex: /(business chat|business chats|facebook user|page is unavailable on messenger|your privacy)/i, label: 'Generic shell / unavailable page', weight: 3 },
                { regex: /(thanks for supporting my page|would you like me to consider you)/i, label: 'Unsolicited outreach solicitation', weight: 3 },
                { regex: /(what.?s your zodiac|zodiac signs)/i, label: 'Zodiac prompt', weight: 3 },
                { regex: /(my friend (?:saw|found) your profile|too shy to message|could you dm (?:him|her)|message my friend|message her on)/i, label: 'Third-party reach-out', weight: 3 },
                { regex: /(you.?re (?:exactly|just) my type|you look like my type|romance|date you|soulmate|my type lol)/i, label: 'Romance lure language', weight: 3 },
                { regex: /(telegram|t\\.me|whatsapp|signal|snapchat|discord|line)[^\\w]?(?:@|id[:\\s]*)?[A-Za-z0-9_.-]{4,}/i, label: 'External contact handle', weight: 3 },
                { regex: /@(?:[A-Za-z0-9_.-]{4,})/i, label: 'External contact handle', weight: 2 }
            ];
            let score = 0;
            const hits = [];
            const lower = text.toLowerCase();
            patterns.forEach((p) => { if (p.regex.test(lower)) { score += p.weight; hits.push(p.label); } });
            const risk = score >= 4 ? 'Dangerous' : score >= 2 ? 'Caution' : 'Safe';
            return { risk, hits };
        };

        const setVerdict = (risk, reasons) => {
            const color = risk === 'Dangerous' ? '#ff6b6b' : risk === 'Caution' ? '#f5c862' : '#5be18a';
            verdictPill.textContent = risk;
            verdictPill.style.background = `${color}20`;
            verdictPill.style.border = `1px solid ${color}55`;
            verdictPill.style.color = color;
            const cautionQrTips = `
                <div class="node-summary" style="margin:6px 0 0 0;">
                    If this came from a QR, check: misaligned/peeling stickers, a QR label slapped over another code, mismatched branding/text,
                    or being asked to pay/login from a poster in the wild. Favor codes on official receipts/packaging; ask the vendor to confirm.
                </div>`;
            const attachmentNote = (reasons || []).some((r) => /(attachment|installer|update)/i.test(r))
                ? `<div class="node-summary" style="margin:6px 0 0 0;">Attachment warning: we cannot scan files. Treat unexpected downloads or installers as high risk and verify with IT before opening.</div>`
                : '';
            const extra = `${risk === 'Caution' ? cautionQrTips : ''}${attachmentNote}`;
            reasonList.innerHTML = (reasons && reasons.length)
                ? `<ul class="flag-list">${reasons.map((r) => `<li>${r}</li>`).join('')}</ul>${extra}`
                : `No clear issues detected. Still be cautious.${extra}`;
        };

        const renderLinks = (items) => {
            if (!items || !items.length) {
                linksBlock.textContent = 'No links found.';
                return;
            }
            linksBlock.innerHTML = items.map((i) => `
                <div>
                    <strong>${i.risk}</strong>
                    <div class="node-summary" style="margin:4px 0;">${i.url}</div>
                    <div class="node-summary" style="font-size:11px;color:rgba(245,247,250,0.6);">${i.flags?.length ? i.flags.join(' • ') : 'No flags'}</div>
                </div>
            `).join('');
        };

        const renderOsint = (items) => {
            if (!items || !items.length) {
                osintBlock.textContent = 'No OSINT lookups yet.';
                return;
            }
            osintBlock.innerHTML = items.map((i) => `
                <div>
                    <div class="node-summary" style="margin-bottom:4px;font-weight:600;">${i.url}</div>
                    <div class="node-summary" style="font-size:11px;">${i.phish === true ? 'Flagged in phish feed' : i.phish === false ? 'Not in phish feed' : i.phish}</div>
                    <div class="node-summary" style="font-size:11px;">${i.urlhaus === true ? 'Listed in URLHaus' : i.urlhaus === false ? 'Not in URLHaus' : i.urlhaus}</div>
                </div>
            `).join('');
        };

        const fetchOsintForLinks = async (urls, progressCallback) => {
            const results = [];
            for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                try {
                    const result = { url, phish: false, urlhaus: false };
                    results.push(result);
                    if (progressCallback) progressCallback((i + 1) / urls.length * 100);
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (e) {
                    results.push({ url, phish: 'Error', urlhaus: 'Error' });
                }
            }
            return results;
        };

        const runRiskPipeline = async (text, origin = 'qr') => {
            const urls = extractUrls(text || '');
            const msgAnalysis = analyzeMessageHeuristics(text || '');
            const linkAnalyses = urls.map(analyzeLinkHeuristics);
            const osintResults = await fetchOsintForLinks(urls);

            renderLinks(linkAnalyses);
            renderOsint(osintResults);

            const allReasons = [...msgAnalysis.hits.map(describeHit), ...linkAnalyses.flatMap(l => l.flags || [])];
            const hasForceDanger = msgAnalysis.hits.some(h => forceDangerLabels.has(h));
            const maxLinkRisk = linkAnalyses.reduce((max, l) => l.risk === 'Dangerous' ? 'Dangerous' : (l.risk === 'Caution' && max !== 'Dangerous' ? 'Caution' : max), 'Safe');
            let finalRisk = hasForceDanger ? 'Dangerous' : (msgAnalysis.risk === 'Dangerous' || maxLinkRisk === 'Dangerous' ? 'Dangerous' : (msgAnalysis.risk === 'Caution' || maxLinkRisk === 'Caution' ? 'Caution' : 'Safe'));

            if (origin === 'qr' && finalRisk === 'Safe' && (urls.length || msgAnalysis.hits.length)) {
                finalRisk = 'Caution';
                allReasons.push('QR scan: payload contained signals; treated as caution.');
            }

            setVerdict(finalRisk, allReasons);

            if (ocrPreview && origin === 'qr') {
                const safeText = text ? text.replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'No text.';
                ocrPreview.innerHTML = `<div class="node-summary" style="white-space:pre-wrap;">${safeText}</div>`;
            }
        };

        const loadImageFlexible = async (file) => {
            try { return await createImageBitmap(file); }
            catch {
                const blobUrl = URL.createObjectURL(file);
                const img = await new Promise((resolve, reject) => {
                    const el = new Image();
                    el.onload = () => resolve(el);
                    el.onerror = reject;
                    el.src = blobUrl;
                });
                URL.revokeObjectURL(blobUrl);
                return img;
            }
        };

        const toCanvas = (source, { maxDim = 1200, highContrast = false, threshold = 175, invert = false } = {}) => {
            const canvas = document.createElement('canvas');
            let { width, height } = source;
            const scale = Math.min(1, maxDim / Math.max(width, height));
            if (scale < 1) { width = Math.floor(width * scale); height = Math.floor(height * scale); }
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(source, 0, 0, width, height);
            if (highContrast) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const dataArr = imageData.data;
                for (let i = 0; i < dataArr.length; i += 4) {
                    const r = dataArr[i], g = dataArr[i + 1], b = dataArr[i + 2];
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    const val = gray > threshold ? 255 : 0;
                    const finalVal = invert ? 255 - val : val;
                    dataArr[i] = dataArr[i + 1] = dataArr[i + 2] = finalVal;
                }
                ctx.putImageData(imageData, 0, 0);
            }
            return canvas;
        };

        const decodeQrImage = async (file) => {
            const source = await loadImageFlexible(file);

            const binarize = (imageData, threshold = 160) => {
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const v = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    const val = v > threshold ? 255 : 0;
                    data[i] = data[i + 1] = data[i + 2] = val;
                }
                return imageData;
            };

            const attemptDecode = (img, { scale = 1, rotate = 0, threshold = null } = {}) => {
                const baseW = img.width || img.videoWidth || img.naturalWidth;
                const baseH = img.height || img.videoHeight || img.naturalHeight;
                const w = Math.max(1, Math.floor(baseW * scale));
                const h = Math.max(1, Math.floor(baseH * scale));

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                if (rotate % 180 === 0) {
                    canvas.width = w;
                    canvas.height = h;
                } else {
                    canvas.width = h;
                    canvas.height = w;
                }

                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate((rotate * Math.PI) / 180);
                ctx.drawImage(img, -w / 2, -h / 2, w, h);
                ctx.restore();

                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                if (threshold !== null) {
                    imageData = binarize(imageData, threshold);
                }

                try {
                    const result = jsQR(imageData.data, canvas.width, canvas.height, { inversionAttempts: 'attemptBoth' });
                    return result?.data || '';
                } catch (err) {
                    console.warn('jsQR decode error', err);
                    return '';
                }
            };

            const scales = [1, 1.3, 1.6];
            const rotations = [0, 90, 180, 270];
            const thresholds = [null, 180, 140];

            for (const sc of scales) {
                for (const rot of rotations) {
                    for (const th of thresholds) {
                        const decoded = attemptDecode(source, { scale: sc, rotate: rot, threshold: th });
                        if (decoded) return decoded;
                    }
                }
            }
            // Fallback: try ZXing if available
            try {
                if (window.ZXing && ZXing.BrowserQRCodeReader) {
                    const reader = new ZXing.BrowserQRCodeReader();
                    const baseCanvas = document.createElement('canvas');
                    const bw = source.width || source.videoWidth || source.naturalWidth;
                    const bh = source.height || source.videoHeight || source.naturalHeight;
                    baseCanvas.width = bw;
                    baseCanvas.height = bh;
                    const bctx = baseCanvas.getContext('2d');
                    bctx.drawImage(source, 0, 0, bw, bh);
                    const imgEl = new Image();
                    imgEl.src = baseCanvas.toDataURL('image/png');
                    await new Promise((resolve, reject) => {
                        imgEl.onload = resolve;
                        imgEl.onerror = reject;
                    });
                    const res = await reader.decodeFromImageElement(imgEl);
                    if (res?.text) return res.text;
                }
            } catch (e) {
                console.warn('ZXing fallback failed', e);
            }
            return '';
        };

        const recognizeCanvas = async (canvas, onProgress) => {
            const { data } = await Tesseract.recognize(canvas, 'eng', {
                logger: (m) => {
                    if (m.status === 'recognizing text' && onProgress) {
                        onProgress(m.progress);
                    }
                },
                tessedit_pageseg_mode: 6,
                preserve_interword_spaces: 1
            });
            return (data?.text || '').trim();
        };

        const runOcr = async (file, { statusCallback, photoMode = false } = {}) => {
            const source = await loadImageFlexible(file);
            const basePasses = [
                { maxDim: 1200, highContrast: false, threshold: 175, minLen: 12, name: 'Standard' },
                { maxDim: 1100, highContrast: true, threshold: 155, invert: false, minLen: 10, name: 'High contrast' },
                { maxDim: 900, highContrast: true, threshold: 150, invert: true, minLen: 6, name: 'Inverted' },
            ];
            const photoPasses = photoMode ? [
                { maxDim: 1600, highContrast: true, threshold: 140, invert: false, minLen: 8, name: 'Photo boost' },
                { maxDim: 1600, highContrast: true, threshold: 130, invert: true, minLen: 8, name: 'Photo boost (invert)' },
            ] : [];
            const passes = [...photoPasses, ...basePasses];
            
            for (let i = 0; i < passes.length; i++) {
                const pass = passes[i];
                if (statusCallback) {
                    statusCallback(`OCR: ${pass.name}...`, (i / passes.length) * 100);
                }
                try {
                    const canvas = toCanvas(source, pass);
                    const txt = await recognizeCanvas(canvas, (progress) => {
                        if (statusCallback) {
                            const baseProgress = (i / passes.length) * 100;
                            const passProgress = (progress / passes.length) * 100;
                            statusCallback(`OCR: ${pass.name} ${Math.round(progress * 100)}%`, baseProgress + passProgress);
                        }
                    });
                    if (txt.length >= (pass.minLen || 6)) {
                        if (statusCallback) statusCallback('OCR complete', 100);
                        return txt;
                    }
                } catch (e) {
                    console.warn(`OCR pass ${i + 1} failed:`, e.message);
                }
            }
            return '';
        };

        scanText.addEventListener('click', async () => {
            const text = textInput.value.trim();
            if (!text) {
                textStatus.textContent = 'Please enter some text.';
                return;
            }

            scanText.disabled = true;
            textProgress.classList.add('active');
            textStatus.innerHTML = 'Extracting URLs...<span class="processing-spinner"></span>';
            textProgressFill.style.width = '10%';

            const urls = extractUrls(text);
            textProgressFill.style.width = '30%';
            
            const msgAnalysis = analyzeMessageHeuristics(text);
            textProgressFill.style.width = '50%';

            const linkAnalyses = urls.map(analyzeLinkHeuristics);
            textProgressFill.style.width = '70%';

            textStatus.innerHTML = 'Checking OSINT feeds...<span class="processing-spinner"></span>';
            const osintResults = await fetchOsintForLinks(urls, (progress) => {
                textProgressFill.style.width = `${70 + (progress * 0.2)}%`;
            });
            textProgressFill.style.width = '90%';

            renderLinks(linkAnalyses);
            renderOsint(osintResults);

            const allReasons = [...msgAnalysis.hits.map(describeHit), ...linkAnalyses.flatMap(l => l.flags || [])];
            const hasForceDanger = msgAnalysis.hits.some(h => forceDangerLabels.has(h));
            const maxLinkRisk = linkAnalyses.reduce((max, l) => l.risk === 'Dangerous' ? 'Dangerous' : (l.risk === 'Caution' && max !== 'Dangerous' ? 'Caution' : max), 'Safe');
            const finalRisk = hasForceDanger ? 'Dangerous' : (msgAnalysis.risk === 'Dangerous' || maxLinkRisk === 'Dangerous' ? 'Dangerous' : (msgAnalysis.risk === 'Caution' || maxLinkRisk === 'Caution' ? 'Caution' : 'Safe'));

            setVerdict(finalRisk, allReasons);

            textProgressFill.style.width = '100%';
            textStatus.textContent = 'Scan complete';
            setTimeout(() => {
                textProgress.classList.remove('active');
                textProgressFill.style.width = '0%';
            }, 2000);
            
            scanText.disabled = false;
        });

        scanShot.addEventListener('click', async () => {
            const file = shotInput.files[0];
            if (!file) {
                shotStatus.textContent = 'Please select an image.';
                return;
            }

            scanShot.disabled = true;
            shotProgress.classList.add('active');
            shotStatus.innerHTML = 'Loading image...<span class="processing-spinner"></span>';
            shotProgressFill.style.width = '5%';

            try {
                const photoModeChecked = document.getElementById('shotPhotoMode')?.checked;
                const ocrText = await runOcr(file, {
                    photoMode: !!photoModeChecked,
                    statusCallback: (msg, progress) => {
                        shotStatus.innerHTML = `${msg}<span class="processing-spinner"></span>`;
                        shotProgressFill.style.width = `${Math.min(progress * 0.7, 70)}%`;
                    }
                });

                if (!ocrText) {
                    shotStatus.textContent = 'No text detected in image.';
                    setTimeout(() => {
                        shotProgress.classList.remove('active');
                        shotProgressFill.style.width = '0%';
                    }, 2000);
                    scanShot.disabled = false;
                    return;
                }

                ocrPreview.textContent = ocrText.substring(0, 300) + (ocrText.length > 300 ? '...' : '');
                shotProgressFill.style.width = '75%';

                const urls = extractUrls(ocrText);
                shotProgressFill.style.width = '80%';

                const msgAnalysis = analyzeMessageHeuristics(ocrText);
                const linkAnalyses = urls.map(analyzeLinkHeuristics);
                shotProgressFill.style.width = '85%';

                shotStatus.innerHTML = 'Checking OSINT...<span class="processing-spinner"></span>';
                const osintResults = await fetchOsintForLinks(urls, (progress) => {
                    shotProgressFill.style.width = `${85 + (progress * 0.1)}%`;
                });

                renderLinks(linkAnalyses);
                renderOsint(osintResults);

                const allReasons = [...msgAnalysis.hits.map(describeHit), ...linkAnalyses.flatMap(l => l.flags || [])];
                const hasForceDanger = msgAnalysis.hits.some(h => forceDangerLabels.has(h));
                const maxLinkRisk = linkAnalyses.reduce((max, l) => l.risk === 'Dangerous' ? 'Dangerous' : (l.risk === 'Caution' && max !== 'Dangerous' ? 'Caution' : max), 'Safe');
                const finalRisk = hasForceDanger ? 'Dangerous' : (msgAnalysis.risk === 'Dangerous' || maxLinkRisk === 'Dangerous' ? 'Dangerous' : (msgAnalysis.risk === 'Caution' || maxLinkRisk === 'Caution' ? 'Caution' : 'Safe'));

                setVerdict(finalRisk, allReasons);

                shotProgressFill.style.width = '100%';
                shotStatus.textContent = 'Screenshot scan complete';
                setTimeout(() => {
                    shotProgress.classList.remove('active');
                    shotProgressFill.style.width = '0%';
                }, 2000);

            } catch (e) {
                console.error('OCR error:', e);
                shotStatus.textContent = `Error: ${e.message}`;
                setTimeout(() => {
                    shotProgress.classList.remove('active');
                    shotProgressFill.style.width = '0%';
                }, 3000);
            }

            scanShot.disabled = false;
        });

        if (scanQr) {
            scanQr.addEventListener('click', async () => {
                const file = qrInput?.files?.[0];
                if (!file) {
                    qrStatus.textContent = 'Please select a QR image.';
                    return;
                }
                scanQr.disabled = true;
                qrStatus.textContent = 'Decoding QR...';
                try {
                    const payload = await decodeQrImage(file);
                    if (!payload) {
                        qrStatus.textContent = 'No QR detected or unreadable. Try a clearer QR image or a straight-on photo.';
                        scanQr.disabled = false;
                        return;
                    }
                    qrStatus.textContent = 'QR decoded. Checking risk...';
                    await runRiskPipeline(payload, 'qr');
                    qrStatus.textContent = 'QR scan complete';
                } catch (e) {
                    qrStatus.textContent = `Error: ${e.message}`;
                }
                scanQr.disabled = false;
            });
        }
    })();
    </script>
</body>
</html>

